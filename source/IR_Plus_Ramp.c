#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTMotor)
#pragma config(Hubs,  S2, HTServo,  none,     none,     none)
#pragma config(Sensor, S3,     gyro,           sensorI2CHiTechnicGyro)
#pragma config(Sensor, S4,     IR,             sensorI2CCustom)
#pragma config(Motor,  mtr_S1_C1_1,     DriveFL,       tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     DriveBL,       tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     DriveFR,       tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     DriveBR,       tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C3_1,     FRM,           tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     Lift,          tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C4_1,     EG1,           tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     EG2,           tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S2_C1_1,    autoArm,              tServoStandard)
#pragma config(Servo,  srvo_S2_C1_2,    spinny,               tServoContinuousRotation)
#pragma config(Servo,  srvo_S2_C1_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messagesvalidateLongAddresvalidateLongAddresvalidateLongAddresvalidateLongAddress
#include "TeleOp_functions.h"  // an H file that we wrote implementing various functions
#include "autonomous_functions.h"	// an H file that we wrote implementing various functions
#include "hitechnic-sensormux.h"


const tMotor DriveMotors[] = { DriveFL, DriveBL, DriveFR, DriveBR };  //an array that describes the Drive motors
const int N_MOTORS = 4;

void initializeRobot() {
	servo[autoArm] = 255;
}


float Heading ()       { return compassBearing (time1[T1], gyro); }
int     IRSensorValue () { return IRSensorRegion (IR, false); }
long    Time ()          { return time1[T1]; }
int     AftDistance ()   { return SensorValue [AFT_SONOR]; }
int     LeftDistance ()  { return SensorValue [LEFT_SONOR]; }
void    ZeroEncoders ()
{ for (int i = 0; i < N_MOTORS; ++i)
    nMotorEncoder[DriveMotors[i]] = 0;
}

int     EncoderTicks ()
{ int sum = 0;
  for (int i = 0; i < N_MOTORS; ++i)
    sum += nMotorEncoder[DriveMotors[i]];
  return sum;
}


void DriveAtHeading (float heading)
{ float current = Heading ();
  omnimove_in_direction (heading - current, DriveMotors, 0);
}

void Stop ()
{ for (int i = 0; i < N_MOTORS; ++i)
    motor[DriveMotors[i]] = 0;
}

#define TICKS_BUFFER_SIZE 100
// TODO: Throw out values more than 1stddev off of the mean
float AverageTicksPerCM (float* buffer, int count)
{ const int N = count % TICKS_BUFFER_SIZE;
  float sum = 0.0;
  for (int i = 0; i < N; ++i)
    sum += buffer[i];
  return sum / ((float) N);
}



void DriveWithHeadingDistanceAndConversion (int heading,
                                    int distance,
                                    float ticks_per_cm)
{ while ((EncoderTicks () / ticks_per_cm) < distance)
    { DriveAtHeading (heading);
      wait10Msec (5);
    }
}

// Per documentation, the ultrasonic sensor has a maximum
// range of 2.5m, and return values >254 are "out of range"
// errors. Adjust this to match 
const int MAX_ULTRASONIC_CM = 255;

// TODO: Determine whether or not we want the IR beacon to be
// directly out from the sensor when we dump the block.
const int DESIRED_IR_DIRECTION = 5;

// when we're this distance from the wall, we're at
// the final bucket.
// TODO: Measure the distance from the end of the field
//       to where I4 will have to be to dump a block
//       in the last basket.
const int FAILSAFE_BUCKET_DISTANCE_AFT_CM = 200;

// Drive until either you see the IR sensor or
// you're at the last bucket. 
//
// BONUS: Return a best estimate of how many motor
// encoder ticks it takes to go 1 cm.
float DriveToIROrFailsafe (float fwd_heading)
{ int travel_start = AftDistance ();
  float ticks_per_cm_buffer[TICKS_BUFFER_SIZE];
  int ticks_per_cm = -1;
  int ticks = 0;
  ZeroEncoders ();
  bool stop = false;
  while (! stop)
    { int traveled = AftDistance ();
      float current_ticks = EncoderTicks ();
      if (traveled < MAX_ULTRASONIC_CM)
        ticks_buffer[ticks++ % TICKS_BUFFER_SIZE] =
          current_ticks / ((float) (traveled - travel_start));

      ticks_per_cm = AverageTicksPerCM (ticks_per_cm_buffer, ticks);

      if (DESIRED_IR_DIRECTION == IRSensorValue ())
        { stop = true;
        }
      else if (traveled < MAX_ULTRASONIC_CM) // still in ultrasonic range!
        { if (traveled > FAILSAFE_BUCKET_DISTANCE_AFT_CM)
            stop = true;
        }
      else // We have to rely on ticks/cm 
        { if ((current_ticks / ticks_per_cm) > FAILSAFE_BUCKET_DISTANCE_AFT_CM)
            stop = true;
        }
      
      DriveAtHeading (fwd_heading);

      if (! stop)
        wait10Msec (5);
    }
  Stop ();
  return ticks_per_cm;
}

// We're at a bucket.
void DumpBlock ()
{ servo[autoArm] = 30;
  wait10Msec(100);
  servo[autoArm] = 255;
}

// TODO: Determine how far (in cm) I4 will have to have
//       driven forward before it goes left.
const int TURNING_POINT_DISTANCE_CM = 300;

// After you've dumped the block in the basket,
// continue driving until you're past the end
// of the ramp.
//
// IMPORTANT ASSUMPTION: The motor encoders have
// *NOT* been reset since the DriveToIROrFailsafe ()
// function ran. We're counting total distance from
// the wall, so we'll need to know how far we've gone.
void DriveToTurningPoint (float fwd_heading, float ticks_per_cm)
{ DriveWithHeadingDistanceAndConversion (fwd_heading,
                                 TURNING_POINT_DISTANCE_CM,
                                 ticks_per_cm);
  Stop ();
}

// Relative to driving forwards or backwards,
// how many encoder ticks does it take to drive
// straight sideways?  Use this to convert.
// TODO: replace this with a more sensible sensor
//       strategy.
const float FWD_TO_SIDEWAYS_CONVERSION = 2.0;

const int DRIVE_LEFT_INITIAL_CM = 100;
const int DRIVE_LEFT_IF_BLOCKED_CM = 50;
const int DRIVE_UP_RAMP_CM = 150;
const int ROBOT_BEHIND_US_THRESHOLD_CM = 50;

// drive sideways to get lined up with the ramp, then
// drive up on to the ramp itself.  
void DriveUpOnRamp (float fwd_heading, float ticks_per_cm)
{ ZeroEncoders ();
  const float left_ticks_per_cm = ticks_per_cm * FWD_TO_SIDEWAYS_CONVERSION;
  DriveWithHeadingDistanceAndConversion (fwd_heading + 90.0,
                                         DRIVE_LEFT_CM,
                                         left_ticks_per_cm);

  Stop ();
  ZeroEncoders ();

  // Loop behind us. Is there a robot there? If so: move over a bit more.
  if (ROBOT_BEHIND_US_THRESHOLD_CM > AftDistance ())
    { DriveWithHeadingDistanceAndConversion (fwd_hedaing + 90.0,
                                             DRIVE_LEFT_IF_BLOCKED_CM,
                                             left_ticks_per_cm);
      Stop ();
      ZeroEncoders ();
    }

  DriveWithHeadingDistanceAndConversion (- fwd_heading,
                                         DRIVE_UP_RAMP_CM,
                                         ticks_per_cm);
  Stop ();
}


// Drive to the end of the ramp. If you see the IR beacon, dump the
// block in it. If you don't see the IR beacon by the time you get
// to the last basket, dump the block there just to be sure.
void IRBlockAndRamp ()
{ ClearTimer (T1);
  float fwd_heading = Heading ();
  
  float ticks_per_cm = DriveToIROrFailsafe (fwd_heading);
  nxtDisplayTextLine(1, "t/cm: %f", ticks_per_cm);
  DumpBlock ();

  ClearTimer (T1);
  fwd_heading = Heading ();

  DriveToTurningPoint (fwd_heading, ticks_per_cm);
  DriveUpOnRamp (fwd_heading, ticks_per_cm);
}

task main ()
{ initializeRobot ();
  waitForStart ();
  IRBlockAndRamp ();
}
